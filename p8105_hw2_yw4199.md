p8105_hw2_yw4199
================
Yaduo Wang
2023-10-01

\#Problem 2

``` r
library(tidyverse)
```

    ## ── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──
    ## ✔ dplyr     1.1.3     ✔ readr     2.1.4
    ## ✔ forcats   1.0.0     ✔ stringr   1.5.0
    ## ✔ ggplot2   3.4.3     ✔ tibble    3.2.1
    ## ✔ lubridate 1.9.2     ✔ tidyr     1.3.0
    ## ✔ purrr     1.0.2     
    ## ── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──
    ## ✖ dplyr::filter() masks stats::filter()
    ## ✖ dplyr::lag()    masks stats::lag()
    ## ℹ Use the conflicted package (<http://conflicted.r-lib.org/>) to force all conflicts to become errors

``` r
library(readxl)
```

``` r
trash_data = read_excel("Trash_Collection_uodated.xlsx", sheet = 1, skip = 1)
```

    ## New names:
    ## • `` -> `...15`
    ## • `` -> `...16`

``` r
#specify the sheet in the Excel file and to omit non-data entries
trash_data = janitor::clean_names(trash_data)
#use reasonable variable names
view(trash_data)

Mr.trash = 
  trash_data |> 
  select(dumpster:homes_powered) |> 
  drop_na(dumpster) |> 
#omit rows that do not include dumpster-specific data
  mutate(homes_powered = weight_tons*500/30)
#Update the data to include a new homes_powered variable based on this calculation.
```

``` r
Pro_data = read_excel("Trash_Collection_uodated.xlsx", sheet = 2, skip = 1)
#specify the sheet in the Excel file and to omit non-data entries
Pro_data = janitor::clean_names(Pro_data)
#use reasonable variable names
view(Pro_data)

Pro.trash = 
  Pro_data |> 
  select(dumpster:homes_powered) |> 
  drop_na(dumpster) |> 
#omit rows that do not include dumpster-specific data
  mutate(homes_powered = weight_tons*500/30)
#Update the data to include a new homes_powered variable based on this calculation.
view(Pro.trash)
```

``` r
Gwy_data = read_excel("Trash_Collection_uodated.xlsx", sheet = 4, skip = 1)
#specify the sheet in the Excel file and to omit non-data entries
Gwy_data = janitor::clean_names(Gwy_data)
#use reasonable variable names
view(Gwy_data)

Gwy.trash = 
  Gwy_data |> 
  select(dumpster:homes_powered) |> 
  drop_na(dumpster) |> 
#omit rows that do not include dumpster-specific data
  mutate(homes_powered = weight_tons*500/30)
#Update the data to include a new homes_powered variable based on this calculation.
view(Gwy.trash)
```

Combine all three datasets.

``` r
#add an additional variable to all datasets before combining
Mr.trash = 
  Mr.trash |> 
  mutate(name_sheet = "Mr.Trash Wheel")
Pro.trash = 
  Pro.trash |> 
  mutate(name_sheet = "Professor Trash Wheel") 
Gwy.trash = 
  Gwy.trash |> 
  mutate(name_sheet = "Gwynnda Trash Wheel") 

#keep the variable type constant
Mr.trash$year = as.numeric(Mr.trash$year)
Pro.trash$year = as.numeric(Pro.trash$year)
Gwy.trash$year = as.numeric(Gwy.trash$year)
```

``` r
#combine all three datasets
three_tidy = 
  bind_rows(Mr.trash, Pro.trash, Gwy.trash) |>
  janitor::clean_names()
view(three_tidy)
```

Description of the data

``` r
sum_weight_Professor = filter(three_tidy, name_sheet == "Professor Trash Wheel")
sum_gwy = filter(three_tidy, 
                 month == "July", year == 2021, name_sheet =="Gwynnda Trash Wheel")
```

This new dataset contains 845 rows, and 15 columns. The columns in this
dataset include: dumpster, month, year, date, weight_tons,
volume_cubic_yards, plastic_bottles, polystyrene, cigarette_butts,
glass_bottles, plastic_bags, wrappers, sports_balls, homes_powered,
name_sheet. The total weight of trash collected by Professor Trash Wheel
is 216.26. The total number of cigarette butts collected by Gwynnda in
July of 2021 is 1.63^{4}.

\#Problem 3

``` r
#Import and clean the dataset. 
baseline_initial = 
  read_csv(file = "MCI_baseline.csv", skip = 1)|>
  janitor::clean_names()
```

    ## Rows: 483 Columns: 6
    ## ── Column specification ────────────────────────────────────────────────────────
    ## Delimiter: ","
    ## chr (1): Age at onset
    ## dbl (5): ID, Current Age, Sex, Education, apoe4
    ## 
    ## ℹ Use `spec()` to retrieve the full column specification for this data.
    ## ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.

``` r
#tidy the dataset
baseline_data = 
  baseline_initial |> 
  mutate(sex = 
      case_match(
        sex, 
        1 ~ "male", 
        0 ~ "female"),
    sex = as.factor(sex)) |> 
   mutate(apoe4 = 
      case_match(
        apoe4, 
        1 ~ "APOE4 carrier", 
        0 ~ "APOE4 non-carrier"),
    apoe4 = as.factor(apoe4)) |> 
  #appropriate encoded of sex and APOE4 carrier status
  subset(current_age < age_at_onset | age_at_onset == ".") 
  #remove any participants who do not meet the stated inclusion criteria
view(baseline_data)

baseline_data_onset = 
  baseline_data |> 
  filter(age_at_onset != ".") |> 
  view()
```

``` r
APOE4_carriers = 
  baseline_data |> 
  filter(apoe4 == "APOE4 carrier") 
```

First, we import data in the form of csv file, and we dropped the first
row. We use reasonable variable names. We apply the appropriate encoded
for sex and APOE4 carrier status variables. Then, we remove any
participants whose current_age is larger than age_at_onset. There are483
participants recruited, and 479 participants who meet the stated
inclusion criteria. There are 93 participants develop MCI. The average
baseline age is 65.0286013. The proportion of women in the study who are
APOE4 carriers is 30.0626305%.

``` r
amyloid_data = 
  read_csv(file = "mci_amyloid.csv", skip = 1) |> 
  janitor::clean_names() |> 
  rename("id" = "study_id") |> 
  filter(baseline!="Na") |> 
  pivot_longer(
    baseline:time_8,
    names_to = "period", 
    values_to = "values") |> 
  view()  
```

    ## Rows: 487 Columns: 6
    ## ── Column specification ────────────────────────────────────────────────────────
    ## Delimiter: ","
    ## chr (5): Baseline, Time 2, Time 4, Time 6, Time 8
    ## dbl (1): Study ID
    ## 
    ## ℹ Use `spec()` to retrieve the full column specification for this data.
    ## ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.

We read in the dataset and skip the first line. We rename the student id
and filter out the unnecessary data. Then, we use the pivot_longer the
rearrange the dataset.

``` r
unique_baseline = anti_join(baseline_data, amyloid_data)
```

    ## Joining with `by = join_by(id)`

``` r
unique_amyloid = anti_join(amyloid_data, baseline_data)
```

    ## Joining with `by = join_by(id)`

``` r
nrow(unique_baseline)
```

    ## [1] 9

``` r
nrow(unique_amyloid)/5
```

    ## [1] 15

9 participants appear in only the baseline and 15 participants only
appear in amyloid datasets. There are total 470 participants.

``` r
#Combine the demographic and biomarker datasets so that only participants who appear in both datasets are retained.
combined_data <- inner_join(baseline_data, amyloid_data, by = "id")
length(unique(combined_data$id))
```

    ## [1] 470

``` r
# export the result as a CSV to my data directory
write.csv(combined_data, "combined_dataset.csv", row.names = FALSE)
```

### Problem 1

We clean the 538 `pols` data, which provides information on the number
of national politicians who are democratic or republican at any given
time. There are some values for which `prez_gop` is `2` – these are
months in which Ford became President following Nixon’s resignation. In
the new `president` variable created as part of our data cleaning, we
code these as `gop` (same as values when `prez_gop` is `1`).

``` r
month_df = 
  tibble(
    month_num = 1:12,
    month_abb = month.abb,
    month = month.name
  )

pols = 
  read_csv("pols-month.csv") |>
  separate(mon, into = c("year", "month_num", "day"), convert = TRUE) |>
  mutate(
    president = recode(prez_gop, "0" = "dem", "1" = "gop", "2" = "gop")) |>
  left_join(x = _, y = month_df) |> 
  select(year, month, everything(), -day, -starts_with("prez")) 
```

    ## Rows: 822 Columns: 9
    ## ── Column specification ────────────────────────────────────────────────────────
    ## Delimiter: ","
    ## dbl  (8): prez_gop, gov_gop, sen_gop, rep_gop, prez_dem, gov_dem, sen_dem, r...
    ## date (1): mon
    ## 
    ## ℹ Use `spec()` to retrieve the full column specification for this data.
    ## ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.
    ## Joining with `by = join_by(month_num)`

We also clean the 538 `snp` data, which contains information related to
Standard & Poor’s stock market index.

``` r
snp = 
  read_csv(
    "snp.csv",
    col_types = cols(date = col_date(format = "%m/%d/%y"))) |>
  separate(date, into = c("year", "month_num", "day"), convert = TRUE) |>
  mutate(
    year = if_else(year > 2023, year - 100, year)) |> 
  left_join(x = _, y = month_df) |> 
  select(year, month, close) 
```

    ## Joining with `by = join_by(month_num)`

Finally, we tidy the `unemployment` data so that it can be merged with
the `pols` and `snp` datasets.

``` r
unemployment = 
  read_csv("unemployment.csv") |>
  rename(year = Year) |>
  pivot_longer(
    Jan:Dec, 
    names_to = "month_abb",
    values_to = "unemployment"
  ) |> 
  left_join(x = _, y = month_df) |> 
  select(year, month, unemployment)
```

    ## Rows: 68 Columns: 13
    ## ── Column specification ────────────────────────────────────────────────────────
    ## Delimiter: ","
    ## dbl (13): Year, Jan, Feb, Mar, Apr, May, Jun, Jul, Aug, Sep, Oct, Nov, Dec
    ## 
    ## ℹ Use `spec()` to retrieve the full column specification for this data.
    ## ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.
    ## Joining with `by = join_by(month_abb)`

Now we merge the three datasets!

``` r
data_538 = 
  left_join(pols, snp) |>
  left_join(x = _, y = unemployment)
```

    ## Joining with `by = join_by(year, month)`
    ## Joining with `by = join_by(year, month)`

``` r
str(data_538)
```

    ## tibble [822 × 13] (S3: tbl_df/tbl/data.frame)
    ##  $ year        : num [1:822] 1947 1947 1947 1947 1947 ...
    ##  $ month       : chr [1:822] "January" "February" "March" "April" ...
    ##  $ month_num   : int [1:822] 1 2 3 4 5 6 7 8 9 10 ...
    ##  $ gov_gop     : num [1:822] 23 23 23 23 23 23 23 23 23 23 ...
    ##  $ sen_gop     : num [1:822] 51 51 51 51 51 51 51 51 51 51 ...
    ##  $ rep_gop     : num [1:822] 253 253 253 253 253 253 253 253 253 253 ...
    ##  $ gov_dem     : num [1:822] 23 23 23 23 23 23 23 23 23 23 ...
    ##  $ sen_dem     : num [1:822] 45 45 45 45 45 45 45 45 45 45 ...
    ##  $ rep_dem     : num [1:822] 198 198 198 198 198 198 198 198 198 198 ...
    ##  $ president   : chr [1:822] "dem" "dem" "dem" "dem" ...
    ##  $ month_abb   : chr [1:822] "Jan" "Feb" "Mar" "Apr" ...
    ##  $ close       : num [1:822] NA NA NA NA NA NA NA NA NA NA ...
    ##  $ unemployment: num [1:822] NA NA NA NA NA NA NA NA NA NA ...

Notice that there are some `NA` values in the `close` and `unemployment`
variables, which indicate that the value of these variables is missing
at those locations.

Let’s talk about the 538 datasets. The `pols` data has 822 observations
and 11 variables and tells us about the party affiliation distribution
(democrat or republican) for governors and senators for a given year
from years 1947 to 2015. It also tells us whether the sitting president
was a democrat or republican. The `snp` data has 787 observations and 3
variables, ranging from years 1950 to 2015. The `unemployment` data has
816 observations and 3 variables ranging from years 1948 to 2015. In
Januarys in or after 1975 in which a democrat was president, the
**average unemployment rate was 6.57**. The average unemployment rate
over the same time period in which a republican was president was 6.47.
